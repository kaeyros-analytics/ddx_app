plot_lot_health_index <- plot_lot_health_index %>% add_trace(data = as.data.frame(lot_health_inv_dataframe[1:n_11,]),
x = ~date_ts[1: n_11], y = ~get("lot_health_inv_dataframe[1:n_11, ]"),
mode = 'lines', line = list(color = "#6495ED"),
hovertext = paste('Date: ',"<b>",date_ts[1: n_11], "</b>",
'<br>Iot health index:',"<b>",
round(lot_health_inv_dataframe[1:n_11,],2), "</b>"),
hoverinfo = 'text')
plot_lot_health_index <- plot_lot_health_index %>% add_trace(data = as.data.frame(lot_health_inv_dataframe[n_22:nbr_row1,]),
x = ~date_ts[n_22:nbr_row1], y = ~get("lot_health_inv_dataframe[n_22:nbr_row1, ]"),
mode = 'lines', line = list(color = "#ff0000"),
hovertext = paste('Date: ',"<b>",date_ts[n_22:nbr_row1], "</b>",
'<br>Predicted iot health index:',"<b>",
round(lot_health_inv_dataframe[n_22:nbr_row1,],2), "</b>"),
hoverinfo = 'text', showlegend = F)
# Confidence interval with the function add_ribbons
plot_lot_health_index <- plot_lot_health_index %>% add_ribbons(x = date_ci1,
ymin = lower1,
ymax = upper1,
color = I("#87A2FB"),
showlegend = F,
hoverinfo="text",
hovertext = paste('Date:',"<b>",date_ci1, "</b> \n",
'Upper:',"<b>",upper1, "</b> \n",
'Lower:',"<b>",lower1, "</b>"))
plot_lot_health_index <- plot_lot_health_index %>% layout(title = "",
xaxis = list(title = "Date"),
yaxis = list (title = ""))
plot_lot_health_index <- plot_lot_health_index %>%
config(displayModeBar = T, displaylogo = FALSE, modeBarButtonsToRemove = list(
'sendDataToCloud',
#'toImage',
#'autoScale2d',
'toggleSpikelines',
'resetScale2d',
'lasso2d',
'zoom2d',
'pan2d',
'select2d'#,
#'hoverClosestCartesian'#,
#'hoverCompareCartesian'
),
scrollZoom = T)
plot_lot_health_index
runApp()
runApp()
runApp()
shiny::runApp()
test2 <- customers_data_init
cols <- sapply(df_testdata, is.numeric)
test2 <- rescale(test2[cols])
rescale <- function(x) (x-min(x))/(max(x) - min(x)) * 100
test2 <- rescale(test2[cols])
test2[cols] <- rescale(test2[cols])
test2 <- rescale(test2)
test2 <- rescale(test2[cols])
test2[cols] = t(apply(test2[cols], 1, function(r)r*attr(test2[cols],'scaled:scale') + attr(test2[cols], 'scaled:center')))
cols <- sapply(df_testdata, is.numeric)
test2 <- customers_data_init
cols <- sapply(test2, is.numeric)
test3 <- df_testdata
cols1 <- sapply(df_testdata, is.numeric)
test2[cols] = data.frame(t(apply(test2[cols], 1, function(r)r*attr(test2[cols],'scaled:scale') + attr(test2[cols], 'scaled:center'))))
View(test2)
str(df_testdata)
cols1 <- sapply(df_testdata, is.numeric)
test4 <- df_testdata[cols1,]
test2[cols,] = data.frame(t(apply(test2[cols,], 1, function(r)r*attr(test2[cols,],'scaled:scale') + attr(test2[cols,], 'scaled:center'))))
test2[cols,] = data.frame(t(apply(test2[cols], 1, function(r)r*attr(test2[cols],'scaled:scale') + attr(test2[cols], 'scaled:center'))))
price <- customers_data_init$dynamic_pricing * attr(customers_data_init$dynamic_pricing, 'scaled:scale') + attr(customers_data_init$dynamic_pricing, 'scaled:center')
price <- customers_data_init$dynamic_pricing
price * attr(price, 'scaled:scale') + attr(price, 'scaled:center')
test3 <- df_testdata
cols1 <- sapply(df_testdata, is.numeric)
test3[cols] <- scale(test3[cols] , center = TRUE, scale = TRUE)
View(test3)
test3[cols] <- data.frame(t(apply(test3[cols], 1, function(r)r*attr(test3[cols],'scaled:scale') + attr(test3[cols], 'scaled:center'))))
test3[cols] <- scale(test3[cols] , center = TRUE, scale = TRUE)
test3 <- df_testdata
cols <- sapply(df_testdata, is.numeric)
test3[cols] <- scale(test3[cols] , center = TRUE, scale = TRUE)
x.orig <- test3
x.orig[cols] <- t(apply(x.orig[cols], 1, function(r)r*attr(x.orig[cols],'scaled:scale') + attr(x.orig[cols], 'scaled:center')))
x.orig <- test3
x.orig[cols] <- as.data.frame(t(apply(x.orig[cols], 1, function(r)r*attr(x.orig[cols],'scaled:scale') + attr(x.orig[cols], 'scaled:center'))))
names(x.orig)
View(x.orig)
x.orig <- test3 %>%
select(-c("client_id" , "machine_id", "date"))
x.orig <- test3 %>%
select(-("client_id" , "machine_id", "date"))
x.orig <- test3 %>%
select(-("client_id", "machine_id", "date"))
x.orig <- test3 %>%
select(-(client_id, machine_id, date))
x.orig <- test3 %>%
select(-c(client_id, machine_id, date))
x.orig <- test3 %>%
select((client_id, machine_id, date))
x.orig <- test3 %>%
dplyr::selectselect((client_id, machine_id, date))
x.orig <- test3 %>%
dplyr::select((client_id, machine_id, date))
x.orig <- test3 %>%
dplyr::select(client_id, machine_id, date)
test3 <- df_testdata
x.orig <- test3 %>%
dplyr::select(-c(client_id, machine_id, date))
x.orig <- as.data.frame(t(apply(x.orig, 1, function(r)r*attr(x.orig,'scaled:scale') + attr(x.orig, 'scaled:center'))))
x.orig <- as.matrix(x.orig)
x.orig <- as.data.frame(t(apply(x.orig, 1, function(r)r*attr(x.orig,'scaled:scale') + attr(x.orig, 'scaled:center'))))
test3[cols] <- scale(test3[cols] , center = TRUE, scale = TRUE)
x.orig <- test3 %>%
dplyr::select(-c(client_id, machine_id, date))
x.orig <- as.matrix(x.orig)
x.orig <- as.data.frame(t(apply(x.orig, 1, function(r)r*attr(x.orig,'scaled:scale') + attr(x.orig, 'scaled:center'))))
View(x.orig)
x.orig <- test3 %>%
dplyr::select(-c(client_id, machine_id, date))
x.orig <- as.matrix(x.orig)
x.orig
# extented fucntion
find_funs <- function(f) {
# Returns dataframe with two columns:
# `package_name`: packages(s) which the function is part of (chr)
# `builtin_package`:  whether the package comes with standard R (a 'builtin'  package)
# Arguments:
# f: name of function for which the package(s) are to be identified.
if ("tidyverse" %in% rownames(installed.packages()) == FALSE) {
cat("tidyverse is needed for this fuction. Please install. Stopping")
stop()}
suppressMessages(library(tidyverse))
# search for help in list of installed packages
help_installed <- help.search(paste0("^",f,"$"), agrep = FALSE)
# extract package name from help file
pckg_hits <- help_installed$matches[,"Package"]
if (length(pckg_hits) == 0) pckg_hits <- "No_results_found"
# get list of built-in packages
pckgs <- installed.packages()  %>% as_tibble
pckgs %>%
dplyr::filter(Priority %in% c("base","recommended")) %>%
dplyr::select(Package) %>%
distinct -> builtin_pckgs_df
# check for each element of 'pckg hit' whether its built-in and loaded (via match). Then print results.
results <- data_frame(
package_name = pckg_hits,
builtin_pckage = match(pckg_hits, builtin_pckgs_df$Package, nomatch = 0) > 0,
loaded = match(paste("package:",pckg_hits, sep = ""), search(), nomatch = 0) > 0
)
return(results)
}
find_funs("rrscale")
cols <- sapply(df_testdata, is.numeric)
test3 <- df_testdata
cols <- sapply(customers_data_init, is.numeric)
test2 <- customers_data_init
test2[cols] <- rrscale::rrscale(test2[cols] )
install.packages("rrscale")
test2[cols] <- rrscale::rrscale(test2[cols] )
runApp()
find_funs("VARMA")
# extented fucntion
find_funs <- function(f) {
# Returns dataframe with two columns:
# `package_name`: packages(s) which the function is part of (chr)
# `builtin_package`:  whether the package comes with standard R (a 'builtin'  package)
# Arguments:
# f: name of function for which the package(s) are to be identified.
if ("tidyverse" %in% rownames(installed.packages()) == FALSE) {
cat("tidyverse is needed for this fuction. Please install. Stopping")
stop()}
suppressMessages(library(tidyverse))
# search for help in list of installed packages
help_installed <- help.search(paste0("^",f,"$"), agrep = FALSE)
# extract package name from help file
pckg_hits <- help_installed$matches[,"Package"]
if (length(pckg_hits) == 0) pckg_hits <- "No_results_found"
# get list of built-in packages
pckgs <- installed.packages()  %>% as_tibble
pckgs %>%
dplyr::filter(Priority %in% c("base","recommended")) %>%
dplyr::select(Package) %>%
distinct -> builtin_pckgs_df
# check for each element of 'pckg hit' whether its built-in and loaded (via match). Then print results.
results <- data_frame(
package_name = pckg_hits,
builtin_pckage = match(pckg_hits, builtin_pckgs_df$Package, nomatch = 0) > 0,
loaded = match(paste("package:",pckg_hits, sep = ""), search(), nomatch = 0) > 0
)
return(results)
}
find_funs("VARMA")
# use parse_time in order to create standard ambiguous date format.
customers_data_init1 <- customers_data_init %>%
mutate(date = as.Date(date , format = "%Y-%m-%d"),
year_ = lubridate::year(date))
df_filter123 <- customers_data_init1 %>%
filter( client_id == "client_0",
machine_id == "M_001") %>%
dplyr::select(dynamic_pricing, lot_health_index, GPR, avg_temperature_month, inflation_rate, DEU_dmd, date, year_)
class(df_filter123)
mts_df_filter123 <- stats::ts(df_filter123[- c(7,8)],
frequency = 12,
start = c(min(df_filter123$year_), 1),
end = c(max(df_filter123$year_), 12))
m2 <- MTS::VARMA(mts_df_filter123,p=2,q=1)
m2 <- MTS::VARMA(mts_df_filter123,p=0,q=0)
fcast123 <- stats::predict(m2, n.ahead = 12)
fit <- ets(USAccDeaths)
fore <- forecast(fit, h = 48, level = c(80, 95))
fore
p <- plot_ly() %>%
add_lines(x = time(USAccDeaths), y = USAccDeaths,
color = I("black"), name = "observed") %>%
add_ribbons(x = time(fore$mean), ymin = fore$lower[, 2], ymax = fore$upper[, 2],
color = I("gray95"), name = "95% confidence") %>%
add_ribbons(x = time(fore$mean), ymin = fore$lower[, 1], ymax = fore$upper[, 1],
color = I("gray80"), name = "80% confidence") %>%
add_lines(x = time(fore$mean), y = fore$mean, color = I("blue"), name = "prediction")
p
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
# use parse_time in order to create standard ambiguous date format.
df_testdata <- df_testdata %>%
mutate(date = as.Date(date , format = "%Y-%m-%d"),
year_ = lubridate::year(date))
# changing the scale initial vector
rescaled_lot_health_index <- scales::rescale(df_testdata$lot_health_index, to = c(20, 100))
# replace the variable lot_health_index through rescaled variable rescaled_lot_health_index
df_testdata$lot_health_index <- rescaled_lot_health_index
str(df_testdata)
# gpr, industry_demand_forecast, production_index, iot_health_index, tempertature, inflation_rate
# industry_demand_forecast (DEU_dmd), production_index(DEU_prd_index), duration_customer_relation
# not good company_size
# subset the data frame
df_filter2 <- df_testdata %>%
filter( client_id == "client_0",
machine_id == "M_001") %>%
dplyr::select(dynamic_pricing, lot_health_index, GPR, avg_temperature_month, inflation_rate, DEU_dmd, date, year_)
class(df_filter2)
class(df_filter2)
mts_df_filter2 <- stats::ts(df_filter2[- c(7,8)],
frequency = 12,
start = c(min(df_filter2$year_), 1),
end = c(max(df_filter2$year_), 12))
class(mts_df_filter2)
head(mts_df_filter2)
tail(mts_df_filter2)
# min(df_testdata$year_)
# max(df_testdata$year_)
str(mts_df_filter2)
#par(mar = c(2.5,2.5,2.5,2.5))
plot(mts_df_filter2, main = "")
# visualization with autoplot
ggplot2::theme_set(theme_bw())
autoplot(mts_df_filter2) +
ggtitle("Time Series Plot of the Data Frame' Time-Series") +
theme(plot.title = element_text(hjust = 0.5)) #for centering the text
# Main packages - problem: both have different functions VAR
## Testing for stationarity
### tseries - standard test adt.test
apply(mts_df_filter2, 2, tseries::adf.test)
# Alternative: lib fUnitRoots, function
apply(mts_df_filter2, 2, fUnitRoots::adfTest,
lags=0, #maximum number of lags used for error term correction
type="c", #type of unit root regression
title = "ADF Test for mts_df_filter2 Data") #title of the project
# Differencing the whole mts
stnry1 <- MTS::diffM(mts_df_filter2) #difference operation on a vector of time series. Default order of differencing is 1.
# Creating a VAR model with vars
var.a.mts_df_filter2 <- vars::VAR(stnry1,
lag.max = 9, #highest lag order for lag length selection according to the choosen ic
ic = "AIC", #information criterion
type = "none") #type of deterministic regressors to include
summary(var.a.mts_df_filter2)
# we forecast over a short horizon because beyond short horizon prediction becomes unreliable or uniform
fcast1 = stats::predict(var.a.mts_df_filter2, n.ahead = 12)
fcast1
# Forecasting the lot_health_index
lot_health = fcast1$fcst[2] # type list
# Extracting the forecast column
x_predict. = lot_health$lot_health_index[,1]
# Extract the last values from the variable dynamic_pricing
yy <- tail(mts_df_filter2)[,2][6]
lot_health$lot_health_index
# Extract the last values from the variable dynamic_pricing
yy <- tail(mts_df_filter2)[,2][6]
#y <- test[,1][6]
x2_predict. = cumsum(x_predict.) + yy
x2_predict.
# Adding data and forecast to one time series
lot_health_inv <- ts(c(df_filter2[,2], x2_predict.),
start = c(min(df_filter2$year_),1),
end = c(max(df_filter2$year_),12),
frequency = 12)
#convert lot_health_inv to data frame and set a name from the column
lot_health_inv_dataframe <- as.data.frame(lot_health_inv)
colnames(lot_health_inv_dataframe) <- c("x")
# extract the date from the time series lot_health_inv
date_ts <- as.Date(time(lot_health_inv))
#choose a part of data frame for each forecast period
nbr_row1 <- nrow(lot_health_inv_dataframe)
n_period1 <- 12
n_11 <- nbr_row1 - n_period1
n_22 <- nbr_row1 - n_period1 + 1
lot_health$lot_health_index
# Create confidence interval
date_ci1 <- date_ts[n_22:nbr_row1]
lower1 <- round((lot_health$lot_health_index[,2] + yy), 2)
upper1 <- round((lot_health$lot_health_index[,3] + yy), 2)
plot_lot_health_index <- plot_ly()
plot_lot_health_index <- plot_lot_health_index %>% add_trace(data = as.data.frame(lot_health_inv_dataframe[1:n_11,]),
x = ~date_ts[1: n_11], y = ~get("lot_health_inv_dataframe[1:n_11, ]"),
mode = 'lines', line = list(color = "#6495ED"),
hovertext = paste('Date: ',"<b>",date_ts[1: n_11], "</b>",
'<br>Iot health index:',"<b>",
round(lot_health_inv_dataframe[1:n_11,],2), "</b>"),
hoverinfo = 'text')
plot_lot_health_index <- plot_lot_health_index %>% add_trace(data = as.data.frame(lot_health_inv_dataframe[n_22:nbr_row1,]),
x = ~date_ts[n_22:nbr_row1], y = ~get("lot_health_inv_dataframe[n_22:nbr_row1, ]"),
mode = 'lines', line = list(color = "#ff0000"),
hovertext = paste('Date: ',"<b>",date_ts[n_22:nbr_row1], "</b>",
'<br>Predicted iot health index:',"<b>",
round(lot_health_inv_dataframe[n_22:nbr_row1,],2), "</b>"),
hoverinfo = 'text', showlegend = F)
# Confidence interval with the function add_ribbons
plot_lot_health_index <- plot_lot_health_index %>% add_ribbons(x = date_ci1,
ymin = lower1,
ymax = upper1,
color = I("#87A2FB"),
showlegend = F,
hoverinfo="text",
hovertext = paste('Date:',"<b>",date_ci1, "</b> \n",
'Upper:',"<b>",upper1, "</b> \n",
'Lower:',"<b>",lower1, "</b>"))
plot_lot_health_index <- plot_lot_health_index %>% layout(title = "",
xaxis = list(title = "Date"),
yaxis = list (title = ""))
plot_lot_health_index <- plot_lot_health_index %>%
config(displayModeBar = T, displaylogo = FALSE, modeBarButtonsToRemove = list(
'sendDataToCloud',
#'toImage',
#'autoScale2d',
'toggleSpikelines',
'resetScale2d',
'lasso2d',
'zoom2d',
'pan2d',
'select2d'#,
#'hoverClosestCartesian'#,
#'hoverCompareCartesian'
),
scrollZoom = T)
plot_lot_health_index
runApp()
# use parse_time in order to create standard ambiguous date format.
df_testdata <- df_testdata %>%
mutate(date = as.Date(date , format = "%Y-%m-%d"),
year_ = lubridate::year(date))
# changing the scale initial vector
rescaled_lot_health_index <- scales::rescale(df_testdata$lot_health_index, to = c(20, 100))
# replace the variable lot_health_index through rescaled variable rescaled_lot_health_index
df_testdata$lot_health_index <- rescaled_lot_health_index
str(df_testdata)
# gpr, industry_demand_forecast, production_index, iot_health_index, tempertature, inflation_rate
# industry_demand_forecast (DEU_dmd), production_index(DEU_prd_index), duration_customer_relation
# not good company_size
# subset the data frame
df_filter2 <- df_testdata %>%
filter( client_id == "client_0",
machine_id == "M_001") %>%
dplyr::select(dynamic_pricing, lot_health_index, GPR, avg_temperature_month, inflation_rate, DEU_dmd, date, year_)
class(df_filter2)
class(df_filter2)
mts_df_filter2 <- stats::ts(df_filter2[- c(7,8)],
frequency = 12,
start = c(min(df_filter2$year_), 1),
end = c(max(df_filter2$year_), 12))
class(mts_df_filter2)
head(mts_df_filter2)
tail(mts_df_filter2)
# min(df_testdata$year_)
# max(df_testdata$year_)
str(mts_df_filter2)
#par(mar = c(2.5,2.5,2.5,2.5))
plot(mts_df_filter2, main = "")
# visualization with autoplot
ggplot2::theme_set(theme_bw())
autoplot(mts_df_filter2) +
ggtitle("Time Series Plot of the Data Frame' Time-Series") +
theme(plot.title = element_text(hjust = 0.5)) #for centering the text
# Main packages - problem: both have different functions VAR
## Testing for stationarity
### tseries - standard test adt.test
apply(mts_df_filter2, 2, tseries::adf.test)
# Alternative: lib fUnitRoots, function
apply(mts_df_filter2, 2, fUnitRoots::adfTest,
lags=0, #maximum number of lags used for error term correction
type="c", #type of unit root regression
title = "ADF Test for mts_df_filter2 Data") #title of the project
# Differencing the whole mts
stnry1 <- MTS::diffM(mts_df_filter2) #difference operation on a vector of time series. Default order of differencing is 1.
vars::VARselect(stnry1,
type = "none", #type of deterministic regressors to include. We use none becasue the time series was made stationary using differencing above.
lag.max = 10) #highest lag order
# Creating a VAR model with vars
var.a.mts_df_filter2 <- vars::VAR(stnry1,
lag.max = 9, #highest lag order for lag length selection according to the choosen ic
ic = "AIC", #information criterion
type = "none") #type of deterministic regressors to include
summary(var.a.mts_df_filter2)
# Residual diagnostics
#serial.test function takes the VAR model as the input
vars::serial.test(var.a.mts_df_filter2)
#selecting the variables ot_health_index, dynamic_price,avg_market_premium_price
# Granger test for causality
#for causality function to give reliable results we need all the variables of the multivariate time series to be stationary.
vars::causality(var.a.mts_df_filter2, #VAR model
cause = c("lot_health_index")) #cause variable. If not specified then first column of x is used. Multiple variables can be used.
# Forecasting the lot_health_index
lot_health = fcast1$fcst[2] # type list
# we forecast over a short horizon because beyond short horizon prediction becomes unreliable or uniform
fcast1 = stats::predict(var.a.mts_df_filter2, n.ahead = 12,level=c(80,95))
fcast1
?predict
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
set.seed(1)
y <- sin(seq(1, 2*pi, length.out = 100))
x <- 1:100
plotdata <- data.frame(x=x, y=y, lower = (y+runif(100, -1, -0.5)), upper = (y+runif(100, 0.5, 1)))
p <- ggplot(plotdata) + geom_line(aes(y=y, x=x, colour = "sin"))+
geom_ribbon(aes(ymin=lower, ymax=upper, x=x, fill = "band"), alpha = 0.3)+
scale_colour_manual("",values="blue")+
scale_fill_manual("",values="grey12")
fig <- ggplotly()
fig
library(plotly)
set.seed(1987)
pkgs <- c("ggplot2", "mgcv", "MASS")
invisible(lapply(pkgs, require, character.only = TRUE))
load(url('https://hbiostat.org/data/repo/titanic3.sav'))
titanic3 <- na.omit(titanic3[, -c(3,8:14)])
titanic3$class_sex <- apply(titanic3, 1,
function(x) paste(x[1], x[3], collapse = "_"))
titanic3$class_sex <- factor(titanic3$class_sex)
train <- titanic3[sample(row.names(titanic3),
size = round(nrow(titanic3) / 2)), ]
test <- titanic3[!(row.names(titanic3) %in% row.names(train)), ]
sim.data <- expand.grid(sex = c("male", "female"), sibsp = 0,
age = seq(1, 80), pclass = c("1st", "2nd", "3rd"))
glm.fit <- glm(survived ~ poly(age, 2) * sex * pclass + sibsp,
"binomial", train)
inv.logit <- function(x) exp(x) / (1 + exp(x))
glm.pred <- predict(glm.fit, newdata = test, se.fit = TRUE)
pred <- data.frame(mean = inv.logit(glm.pred$fit),
lo = inv.logit(glm.pred$fit - 2 * glm.pred$se.fit),
hi = inv.logit(glm.pred$fit + 2 * glm.pred$se.fit),
survived = test$survived)
pred <- pred[order(pred$mean), ]
pred$id <- seq_along(pred$mean)
row.names(pred) <- NULL
pred <- predict(glm.fit, newdata = sim.data, se.fit = TRUE)
sim.data$mean <- inv.logit(pred$fit)
sim.data$lo <- inv.logit(pred$fit - 2 * pred$se.fit)
sim.data$hi <- inv.logit(pred$fit + 2 * pred$se.fit)
p <- ggplot(titanic3, aes(x = age, y = survived))
p <- p + geom_point()
p <- p + facet_grid(sex ~ pclass)
p <- p + geom_line(data = sim.data, aes(y = mean))
p <- p + geom_ribbon(data = sim.data, aes(y = mean, ymin = lo, ymax = hi),
alpha = .25)
p <- p + labs(x = "Passenger Age", y = "Probability of Survival")
fig <- ggplotly(p)
fig
runApp()
runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
